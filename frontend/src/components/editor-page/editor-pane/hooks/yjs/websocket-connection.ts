/*
 * SPDX-FileCopyrightText: 2022 The HedgeDoc developers (see AUTHORS file)
 *
 * SPDX-License-Identifier: AGPL-3.0-only
 */
import {
  encodeAwarenessUpdateMessage,
  encodeCompleteAwarenessStateRequestMessage,
  encodeDocumentUpdateMessage,
  WebsocketTransporter
} from '@hedgedoc/commons'
import WebSocket from 'isomorphic-ws'
import type { Awareness } from 'y-protocols/awareness'
import type { Doc } from 'yjs'

/**
 * Handles the communication with the realtime endpoint of the backend and synchronizes the given y-doc and awareness with other clients.
 */
export class WebsocketConnection extends WebsocketTransporter {
  constructor(url: URL, doc: Doc, awareness: Awareness) {
    super(doc, awareness)
    this.bindYDocEvents(doc)
    this.bindAwarenessMessageEvents(awareness)
    const websocket = new WebSocket(url)
    this.setupWebsocket(websocket)
  }

  private bindAwarenessMessageEvents(awareness: Awareness) {
    const updateCallback = (
      { added, updated, removed }: { added: number[]; updated: number[]; removed: number[] },
      origin: unknown
    ) => {
      if (origin !== this) {
        this.send(encodeAwarenessUpdateMessage(awareness, [...added, ...updated, ...removed]))
      }
    }
    this.on('disconnected', () => {
      awareness.off('update', updateCallback)
      awareness.destroy()
    })

    this.on('ready', () => {
      awareness.on('update', updateCallback)
    })
    this.on('synced', () => {
      this.send(encodeCompleteAwarenessStateRequestMessage())
      this.send(encodeAwarenessUpdateMessage(awareness, [awareness.doc.clientID]))
    })
  }

  private bindYDocEvents(doc: Doc): void {
    doc.on('destroy', () => this.disconnect())
    doc.on('update', (update: Uint8Array, origin: unknown) => {
      if (origin !== this && this.isSynced() && this.isWebSocketOpen()) {
        this.send(encodeDocumentUpdateMessage(update))
      }
    })
  }
}
