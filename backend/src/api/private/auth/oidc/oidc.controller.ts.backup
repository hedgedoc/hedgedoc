/*
 * SPDX-FileCopyrightText: 2025 The HedgeDoc developers (see AUTHORS file)
 *
 * SPDX-License-Identifier: AGPL-3.0-only
 */
import { AuthProviderType } from '@hedgedoc/commons';
import { FieldNameIdentity } from '@hedgedoc/database';
import {
  Controller,
  Get,
  InternalServerErrorException,
  Param,
  Req,
  Res,
  UnauthorizedException,
} from '@nestjs/common';
import { HttpException } from '@nestjs/common/exceptions/http.exception';
import { ApiTags } from '@nestjs/swagger';
import { Response } from 'express';

import { IdentityService } from '../../../../auth/identity.service';
import { OidcService } from '../../../../auth/oidc/oidc.service';
import { ConsoleLoggerService } from '../../../../logger/console-logger.service';
import { UsersService } from '../../../../users/users.service';
import { OpenApi } from '../../../utils/decorators/openapi.decorator';
import { RequestWithSession } from '../../../utils/request.type';

@ApiTags('auth')
@Controller('/auth/oidc')
export class OidcController {
  constructor(
    private readonly logger: ConsoleLoggerService,
    private usersService: UsersService,
    private identityService: IdentityService,
    private oidcService: OidcService,
  ) {
    this.logger.setContext(OidcController.name);
  }

  @Get(':oidcIdentifier')
  @OpenApi(201, 400, 401)
  async loginWithOpenIdConnect(
    @Req() request: RequestWithSession,
    @Param('oidcIdentifier') oidcIdentifier: string,
    @Res() response: Response,
  ): Promise<void> {
    const code = this.oidcService.generateCode();
    const state = this.oidcService.generateState();
    // Flatten session structure - store directly in session
    request.session.oidcLoginCode = code;
    request.session.oidcLoginState = state;
    request.session.authProviderType = AuthProviderType.OIDC;
    request.session.authProviderIdentifier = oidcIdentifier;
    // Force session save before redirect to ensure cookie is set
    await new Promise<void>((resolve, reject) => {
      if (request.session.save) {
        request.session.save((err) => {
          if (err) {
            this.logger.error('Failed to save session: ' + String(err), undefined, 'loginWithOpenIdConnect');
            reject(err);
          } else {
            this.logger.debug('Session saved for OIDC login', 'loginWithOpenIdConnect');
            resolve();
          }
        });
      } else {
        this.logger.warn('Session save method not available', 'loginWithOpenIdConnect');
        resolve();
      }
    });
    const authorizationUrl = this.oidcService.getAuthorizationUrl(
      oidcIdentifier,
      code,
      state,
    );
    response.redirect(authorizationUrl);
  }

  @Get(':oidcIdentifier/callback')
  @OpenApi(201, 400, 401, 500)
  async callback(
    @Param('oidcIdentifier') oidcIdentifier: string,
    @Req() request: RequestWithSession,
    @Res() response: Response,
  ): Promise<void> {
    try {
      this.logger.debug(`OIDC callback received for ${oidcIdentifier}`, 'callback');
      this.logger.debug(`Session login code present: ${!!request.session.oidcLoginCode}`, 'callback');
      
      const userInfo = await this.oidcService.extractUserInfoFromCallback(
        oidcIdentifier,
        request,
      );
      const oidcUserIdentifier = request.session.providerUserId;
      if (!oidcUserIdentifier) {
        this.logger.error('No OIDC user identifier in callback', undefined, 'callback');
        throw new UnauthorizedException('No OIDC user identifier found');
      }
      
      this.logger.debug(`OIDC user identifier: ${oidcUserIdentifier}`, 'callback');
      
      const identity = await this.oidcService.getExistingOidcIdentity(
        oidcIdentifier,
        oidcUserIdentifier,
      );
      const mayUpdate = this.identityService.mayUpdateIdentity(oidcIdentifier);

      if (identity === null) {
        this.logger.debug('No existing identity, redirecting to new-user', 'callback');
        request.session.newUserData = userInfo;
        // Save session before redirect
        await new Promise<void>((resolve, reject) => {
          if (request.session.save) {
            request.session.save((err) => {
              if (err) {
                this.logger.error('Failed to save session: ' + String(err), undefined, 'callback');
                reject(err);
              } else {
                this.logger.debug('Session saved for new user', 'callback');
                resolve();
              }
            });
          } else {
            this.logger.warn('Session save method not available', 'callback');
            resolve();
          }
        });
        response.redirect('/new-user');
        return;
      }

      const userId = identity[FieldNameIdentity.userId];
      this.logger.debug(`Found existing user: ${userId}`, 'callback');
      
      if (mayUpdate) {
        await this.usersService.updateUser(
          userId,
          userInfo.displayName,
          userInfo.email,
          userInfo.photoUrl,
        );
      }

      request.session.userId = userId;
      request.session.authProviderType = AuthProviderType.OIDC;
      request.session.authProviderIdentifier = oidcIdentifier;
      // Cleanup temporary OIDC data
      request.session.oidcLoginCode = undefined;
      request.session.oidcLoginState = undefined;
      request.session.providerUserId = undefined;
      request.session.newUserData = undefined;
      
      // Force session save before redirect to ensure login persists
      await new Promise<void>((resolve, reject) => {
        if (request.session.save) {
          request.session.save((err) => {
            if (err) {
              this.logger.error('Failed to save session after login: ' + String(err), undefined, 'callback');
              reject(err);
            } else {
              this.logger.debug('Session saved successfully after login', 'callback');
              resolve();
            }
          });
        } else {
          this.logger.warn('Session save method not available', 'callback');
          resolve();
        }
      });
      
      this.logger.debug('Redirecting to /', 'callback');
      response.redirect('/');
    } catch (error) {
      if (error instanceof HttpException) {
        throw error;
      }
      this.logger.error(
        'Error during OIDC callback: ' + String(error),
        error instanceof Error ? error.stack : undefined,
        'callback',
      );
      throw new InternalServerErrorException();
    }
  }
}
